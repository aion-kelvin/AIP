**Title**: Blockhash-based replay attack protection

**Author**: Kelvin Lam ([kelvin@aion.network](mailto:kelvin@aion.network))

**Type**: Core

**Status**: REVIEW

**Created**: 17 December 2018

**Contact**: Kelvin Lam ([kelvin@aion.network](mailto:kelvin@aion.network))

### Summary

A replay attack prevention mechanism that works by allowing transactions to
specify a (optional) block hash that must be present in the chain in order for
the transaction to be accepted.

### Value Proposition

The mechanism provides protection against replay attacks, making it less likely
that users' signed transactions on one Aion-compatible network or branch can be
maliciously broadcasted on a different Aion-compatible network or branch.  The
value for users is that it is safer to use these networks.

### Motivation

Motivation for this mechanism is driven mainly by two concerns:

1. Replay attacks if a hard fork were ever to create two competing chains
2. Replay attacks if anyone uses the same private key on two Aion-compatible
   networks.

Significance of the first concern is illustrated by Ethereum's post-DAO
hard-fork that resulted in the creation of Ethereum and Ethereum Classic.
Immediately after the fork, it was the case that any transaction in the
Ethereum branch of the fork was also a valid transaction on the Ethereum
Classic branch.  Since signed transactions are broadcast throughout the
network, any node on Ethereum network could capture the signed transactions and
then go on the Ethereum Classic network and broadcast that exact same
transaction.  The only thing that would prevent them from being executed was if
the transaction nonce for the account was incorrect.  The inverse case was also
true.  Both chains contained assets with significant value, making them
attractive targets.  As a result, Ethereum developers had to quickly implement
replay protection for Ethereum and the result was implementation of
[EIP-155](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md) in most
Ethereum clients.  EIP-155's design is tied to Ethereum's signature algorithm,
ECDSA, and not applicable with Aion, which uses EdDSA.

The second case is less dangerous, but still poses a threat to anyone who has
used their private key on more than one network.  While this is not a good
practice, it is possible that some users (particularly those inexperienced with
blockchain) may have done this; for example, to have an account on a testnet
with some test transactions that send Aions.  If this user uses the same
private key for an account on the mainnet, then a malicious actor could capture
the testnet transactions and broadcast them on mainnet to waste the victim's
funds.

### Non-Goals 

The following areas are out-of-scope of this proposal:

- 51% attack: different from replay attacks; this mechanism is not designed to
  deter this type of attack
- Not doing anything to try to "prevent" hard forks or competing chains

### Success Metrics

**Percentage of transactions using `beacon` field:** the new field will be
optional.  Omitting the field effectively means that this new replay protection
mechanism does not apply to this transaction.  Tracking its usage will show the
proportion of users who are protected.

**Number of transactions rejected on mainnet and testnet:** monitor this number
on ongoing basis as it shows attempted replay attacks that were prevented by
this mechanism.  It should also be monitored for some weeks prior to the
deploymenet of this feature, as its implementation may deter people from
attempting replay attacks in the first place.  If there are rejections near the
start of deployment that later taper off, that would indicate that it's
preventing people from attempting the replay transactions.

### Description

A new optional field will be added to the specification of a transaction.  This
new field will contain a hash of a block that is present on the chain for which
the transaction is intended.  This field is called the `beacon` field.  A
transaction with a non-empty beacon must only be accepted by the block chain if
that block chain contains a block with that hash.  The mechanism allows for a
transaction to be tied to a particular state of a chain.  Depending on the
block used, this mechanism will ensure that a transaction executes only on a
particular Aion blockchain network or fork of a network.

### Specification

Add a new field to transactions, named `beacon`.  The field is optional; if
empty, it is assumed to have the value 0.  Otherwise, `beacon` is either the
value 0 or an Aion block hash (a 256-bit number).  Since the new field is
optional, backward-compatibility with the previous transaction format is
maintained.

In the kernel, maintain a "beacon list" -- a list of block hashes present in
the blockchain.  The beacon list can be constructed in several ways (details in
_Logic_ section); one simple approach would be that it just has the hash
of every block in the entire chain.

The kernel, when processing transactions, will have a new restriction based on
the transaction's `beacon` field and the state of its `beacon list`.  The rules
are as follows:

- If beacon value is 0, accept the transaction
- If beacon value is not 0 and the value is in the beacon list, accept the
  transaction
- Otherwise, reject the transaction

The overall effect is that transactions can now be associated to a particular
blockchain network or branch within a network with forks.  


### Logic

#### Example case

Assume that the beacon list contains the hashes of all blocks on the chain.

Consider a blockchain where the latest block is 100,000.   A user who wants to
create a transaction for it could use the hash of the latest block.  When a
kernel tries to mine this transaction into block 100,001, it would check the
transaction's `beacon` and accept it because that hash is present in the chain.

If there was a hard fork with a competing sub-chain somewhere earlier, say at
block 95,000, a kernel in that sub-chain would reject this transaction
because, under normal conditions, the competing chain will not have a block
containing the same hash as block 100,000 from the status quo sub-chain.  The
"normal" conditions we are assuming:

1. There is no block hash collision causing two different blocks on the two
subchains to have the same hash
1. The first block after the hard fork of both sub-chains are different.  This
is a reasonable assumption since for them to be same, not only do all
transactions have to be identical, but the timestamp, id of the miner, PoW
solution, and nonce of the block also needs to be identical.

Therefore, this mechanism protects against replay attacks in the hard fork
case.  For the case of replaying transactions between two compatible networks,
the mechanism works similarly.  Two networks should also have different genesis
blocks, which makes it further unlikely that there would be two blocks with the
same hash on both networks.

#### Design and considerations

To implement this AIP, changes to the kernel are mandatory in order for a
kernel to continue functioning as part of the Aion network.  Changes to clients
are needed in order to take advantage of the replay protection that this AIP
provides; however, non-updated clients will continue to function as they do
today.

On the kernel side, implementation consists of maintaining the beacon list and
adding a check to transaction processing to reject transactions with beacons
not present in the beacon list.  

There are several methods to maintain this beacon list.  In the current
implementation of the Aion kernel, there is already functionality that supports
retrieving a block, given a blockhash, from the kernel's database.  At the time
of writing, the main database in use is LevelDB, which is optimized for fast
single-key retrieval.  Depending on the database's cache state, this retrieval
may be from disk (worst-case) or from memory (best-case).  In either case, we
anticipate that the latency and overhead for this operation is negligible, but
timing logs should be added to confirm this.  Therefore, the proposed approach
is to simply use this database as the beacon list.  No additional storage in
memory or disk is needed.

An alternative that was considered was for the beacon list is to store only a
subset of blocks from the chain in a cache that supports fast block hash
look-ups.  However, as the database in the current kernel implementation gives
us fast block hash look-ups for "free," this alternative is provides little
benefit.

Clients that construct transactions will also need changes if they want to make
use of this replay protection mechanism.  The procedure is summarized as
follows:

1. Construct a transaction as normal
1. Add a field called `beacon` 
1. Query the blockchain for a "recent" block number and save its block hash
1. Set the `beacon` value to this block hash

The "recent" block number can be the most recent block in the chain; however,
if the kernel that the client is connected to happens to temporarily be in a
side-chain, the transaction would be rejected once the kernel goes back on to
the main chain.  Therefore, for 'everyday' transactions, it is recommended to
subtract 12 from the most recent block and use that block number instead.  For
high-value transactions, the user may opt to use a less recent block.

The step of querying the blockchain for a block number can pose a problem to
use cases when one wants to construct transactions without an Internet
connection or construct transactions that will be executed at a much later
time.

For transactions that will be executed at a much later time, the client should
just use a recent block number at the time of constructing the transaction.
This transaction will still have replay protection from being played on another
network or any hard fork that has occurred prior to this block.

To support the case of constructing transactions off-line, clients should be
aware of the concept of different Aion networks and have hard-coded default
block hashes to use for the major networks.  The hard-coded values should be
the hash of either the genesis block for that network or the most recent hard
fork, if one exists.  For private networks that the clients do not know about,
they will need to omit the beacon value and therefore not have replay
protection.

The current major clients in the Aion ecosystem are Aion Web3 and Aion Wallet.

The Aion Web3 client needs to be modified so that the the creation of
transactions allows the user to specify an optional beacon value.  If not
specified, it should default to a recent block by querying the kernel.  This
way, users can get the protection without having to do any extra manual work.

The Aion Wallet needs to be updated similarly.

### Risks & Assumptions

The proposed changes will have an effect on the kernel in the sense that each
transaction's beacon value needs to be checked against the blocks database.  We
are assuming that this operation will not have any noticeable impact on
transaction processing time, but will verify this during testing.  If there is
an issue, one of the alternate implementations of constructing the beacon list
can be considered.

We are assuming that block hashes collisions do not occur among any of the
Aion-compatible networks.  However, if it did happen, the implication is that
the hash in question will not be suitable for being used as a beacon.  The
scope of the impact is limited to those blocks.

While block hash collisions are mathematically unlikey, two blockchains could
also have a common block hash if they were configured with the same genesis
block.  If this were to happen, then using the genesis block as a beacon in a
transaction for that network would be unsafe as it could be replayed on the
other network sharing the genesis block.  This is unlikely to happen
intentionally as it provides no benefit to the administrators of those
blockchains.

### Test Cases

(In progress, will be included in later revision when ready for review)


### Implementations

(In progress, will be included in later revision when ready for review)

### Dependencies

None

### Copyright

All AIPs are public domain. Copyright waiver to be linked to
https://creativecommons.org/publicdomain/zero/1.0/.
